{"version":3,"sources":["../src/resolver.js"],"names":["resolveHttpUrl","resolveLocalUrl","resolveString","resolveToReadableStream","url","isHttpUrl","test","content","stream","on","error","res","statusCode","emit","message","path","sourcePath","isLocalUrl","relativePath","dirname","localUrl","join","createReadStream","encoding","input","isQuotedString","slice","defaultResolvers","link","resolvers","placeholder","chunk","reduce","memo","resolver","source","outputStream","isString","objectMode","push","line","column","Error","contentStream","resolvedUrl"],"mappings":";;;;;QAOgBA,c,GAAAA,c;QAgBAC,e,GAAAA,e;QAYAC,a,GAAAA,a;QAaAC,uB,GAAAA,uB;;AAhDhB;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;AACA;;;;;;AAEO,SAASH,cAAT,CAAwBI,GAAxB,EAA6B;AAClC;AACA,MAAMC,YAAY,cAAlB;AACA,MAAI,CAACA,UAAUC,IAAV,CAAeF,GAAf,CAAL,EAA0B,OAAO,IAAP;;AAE1B,MAAMG,UAAU,cAAIC,MAAJ,CAAWJ,GAAX,CAAhB;;AAEA;AACAG,UAAQE,EAAR,CAAW,UAAX,EAAuB,SAASC,KAAT,CAAeC,GAAf,EAAoB;AACzC,QAAIA,IAAIC,UAAJ,KAAmB,GAAvB,EACE,KAAKC,IAAL,CAAU,OAAV,EAAmB,EAAEC,SAAS,qBAAX,EAAkCC,MAAMX,GAAxC,EAAnB;AACH,GAHD;;AAKA,SAAO,EAAEG,gBAAF,EAAWH,QAAX,EAAP;AACD;;AAEM,SAASH,eAAT,CAAyBG,GAAzB,EAA8BY,UAA9B,EAA0C;AAC/C,MAAMC,aAAa,YAAnB;AACA,MAAI,CAACA,WAAWX,IAAX,CAAgBF,GAAhB,CAAL,EAA2B,OAAO,IAAP;;AAE3B,MAAMc,eAAe,eAAKC,OAAL,CAAaH,UAAb,CAArB;AACA,MAAMI,WAAW,eAAKC,IAAL,CAAUH,YAAV,EAAwBd,GAAxB,CAAjB;;AAEA,MAAMG,UAAU,aAAGe,gBAAH,CAAoBF,QAApB,EAA8B,EAAEG,UAAU,MAAZ,EAA9B,CAAhB;;AAEA,SAAO,EAAEhB,gBAAF,EAAWH,KAAKgB,QAAhB,EAAP;AACD;;AAEM,SAASlB,aAAT,CAAuBsB,KAAvB,EAA8B;AACnC,MAAMC,iBAAiB,cAAvB;AACA,MAAI,CAACA,eAAenB,IAAf,CAAoBkB,KAApB,CAAL,EAAiC,OAAO,IAAP;;AAEjC,SAAO,EAAEjB,SAASiB,MAAME,KAAN,CAAY,CAAZ,EAAe,CAAC,CAAhB,CAAX,EAAP;AACD;;AAED,IAAMC,mBAAmB,CAAC3B,cAAD,EAAiBC,eAAjB,EAAkCC,aAAlC,CAAzB;;AAEA;AACA;AACA;AACA;AACO,SAASC,uBAAT,CACLyB,IADK,EAKL;AAAA,MAHAC,SAGA,uEAHYF,gBAGZ;AAAA,MAFAG,WAEA;AAAA,MADAC,KACA;;AAAA,iBACyB,iBAAEC,MAAF,CACvBH,SADuB,EAEvB,UAACI,IAAD,EAAOC,QAAP;AAAA,WACED,QAAQC,SAASN,KAAKxB,GAAd,EAAmBwB,KAAKO,MAAxB,EAAgCL,WAAhC,EAA6CC,KAA7C,CADV;AAAA,GAFuB,EAIvB,IAJuB,CADzB;AAAA,MACQxB,OADR,YACQA,OADR;AAAA,MACiBH,GADjB,YACiBA,GADjB;;AAQA,MAAIgC,qBAAJ;;AAEA,MAAI,iBAAEC,QAAF,CAAW9B,OAAX,CAAJ,EAAyB;AACvB6B,mBAAe,uBAAS,EAAEE,YAAY,IAAd,EAAT,CAAf;;AAEAF,iBAAaG,IAAb,CAAkB;AAChBhC,sBADgB;AAEhB4B,cAAQP,KAAKO,MAFG;AAGhBK,YAAMZ,KAAKY,IAHK;AAIhBC,cAAQb,KAAKa;AAJG,KAAlB;AAMAL,iBAAaG,IAAb,CAAkB,IAAlB;AACD,GAVD,MAUO,IAAI,0BAAWhC,OAAX,CAAJ,EAAyB;AAC9B6B,mBAAe7B,OAAf;AACD,GAFM,MAEA;AACL,UAAM,IAAImC,KAAJ,8CAAoDd,KAAKxB,GAAzD,QAAN;AACD;;AAED,SAAO,EAAEuC,eAAeP,YAAjB,EAA+BQ,aAAaxC,GAA5C,EAAP;AACD","file":"resolver.js","sourcesContent":["import _ from 'lodash';\nimport fs from 'fs';\nimport path from 'path';\nimport got from 'got';\nimport { isReadable } from 'isstream';\nimport through2 from 'through2';\n\nexport function resolveHttpUrl(url) {\n  // TODO: handle relative link in\n  const isHttpUrl = /^https?:\\/\\//;\n  if (!isHttpUrl.test(url)) return null;\n\n  const content = got.stream(url);\n\n  // Manually trigger error since 2XX respsonse doesn't trigger error despite not having expected content\n  content.on('response', function error(res) {\n    if (res.statusCode !== 200)\n      this.emit('error', { message: 'Could not read file', path: url });\n  });\n\n  return { content, url };\n}\n\nexport function resolveLocalUrl(url, sourcePath) {\n  const isLocalUrl = /^[^ ()\"']+/;\n  if (!isLocalUrl.test(url)) return null;\n\n  const relativePath = path.dirname(sourcePath);\n  const localUrl = path.join(relativePath, url);\n\n  const content = fs.createReadStream(localUrl, { encoding: 'utf8' });\n\n  return { content, url: localUrl };\n}\n\nexport function resolveString(input) {\n  const isQuotedString = /^[\"'].*[\"']$/;\n  if (!isQuotedString.test(input)) return null;\n\n  return { content: input.slice(1, -1) };\n}\n\nconst defaultResolvers = [resolveHttpUrl, resolveLocalUrl, resolveString];\n\n// Resolves link to string or stream\n//  - resolvers is an array of synchronus functions that return null, string or stream.\n//  - stream requires processing\n//  - string assumed fully processed\nexport function resolveToReadableStream(\n  link,\n  resolvers = defaultResolvers,\n  placeholder,\n  chunk\n) {\n  const { content, url } = _.reduce(\n    resolvers,\n    (memo, resolver) =>\n      memo || resolver(link.url, link.source, placeholder, chunk),\n    null\n  );\n\n  let outputStream;\n\n  if (_.isString(content)) {\n    outputStream = through2({ objectMode: true });\n\n    outputStream.push({\n      content,\n      source: link.source,\n      line: link.line,\n      column: link.column,\n    });\n    outputStream.push(null);\n  } else if (isReadable(content)) {\n    outputStream = content;\n  } else {\n    throw new Error(`no readable stream or string, resolve '${link.url}'`);\n  }\n\n  return { contentStream: outputStream, resolvedUrl: url };\n}\n"]}