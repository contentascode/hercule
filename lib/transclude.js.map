{"version":3,"sources":["../src/transclude.js"],"names":["Transclude","SYNTAX","hercule","REGEXP","MATCH_GROUP","INDENT_GROUP","LINK_GROUP","aglio","marked","multimarkdown","shiftCursor","content","line","column","newLines","match","length","newColumns","newLine","newColumn","applyReferences","chunk","source","transclusionLink","link","inheritedReferences","references","contentLink","scopeReferences","descendantReferences","contextReferences","find","placeholder","url","nextReferences","uniqBy","options","transclusionSyntax","inheritedParents","inheritedIndent","inheritedHeader","resolvers","pattern","inputBuffer","transclude","cb","self","process","nextTick","push","parents","indent","header","sourceLine","sourceColumn","out","error","message","path","contentStream","resolvedUrl","includes","resolvedSource","resolvedParents","undefined","nestedTransclude","on","inputReadable","streamContent","read","err","pipe","toToken","level","input","slice","index","reverse","join","output","lastIndexOf","toSeparators","separator","separators","map","without","tokenize","lastChunk","nextOffset","tokens","exec","concat","lastIndex","transform","encoding","isPlainObject","eachSeries","toString","next","call","flush","obj"],"mappings":"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","file":"transclude.js","sourcesContent":["import through2 from 'through2';\nimport _ from 'lodash';\nimport async from 'async';\nimport cloneRegExp from 'clone-regexp';\nimport leftsplit from 'left-split';\n\nimport { resolveToReadableStream } from './resolver';\nimport { parseContent } from './parse';\n\nconst SYNTAX = {\n  hercule: {\n    REGEXP: /(^[\\t ]*)?:\\[.*?]\\((.*?)\\)/gm,\n    MATCH_GROUP: 0,\n    INDENT_GROUP: 1,\n    LINK_GROUP: 2,\n  },\n  aglio: {\n    REGEXP: /( *)?(<!-- include\\((.*?)\\) -->)/gim,\n    MATCH_GROUP: 0,\n    INDENT_GROUP: 1,\n    LINK_GROUP: 3,\n  },\n  marked: {\n    REGEXP: /( *)?<<\\[(.*)]/gm,\n    MATCH_GROUP: 0,\n    INDENT_GROUP: 1,\n    LINK_GROUP: 2,\n  },\n  multimarkdown: {\n    REGEXP: /( *)?{{(.*)}}/gm,\n    MATCH_GROUP: 0,\n    INDENT_GROUP: 1,\n    LINK_GROUP: 2,\n  },\n};\n\nfunction shiftCursor(content, { line, column }) {\n  const newLines = (content.match(/\\n/g) || []).length;\n  const newColumns = content.match(/.*$/g)[0].length;\n\n  const newLine = line + newLines;\n  const newColumn = newLines > 0 ? newColumns : column + newColumns;\n\n  return { line: newLine, column: newColumn };\n}\n\nfunction applyReferences(chunk) {\n  const { source, line, column } = chunk;\n  const transclusionLink = chunk.link;\n  const inheritedReferences = chunk.references;\n\n  const {\n    contentLink,\n    scopeReferences,\n    descendantReferences,\n  } = parseContent(transclusionLink, {\n    source,\n    line,\n    column,\n  });\n\n  // Inherited reference take precendence over fallback reference\n  const contextReferences = [...inheritedReferences, ...scopeReferences];\n  const link =\n    _.find(contextReferences, { placeholder: contentLink.url }) || contentLink;\n\n  // Prefer nearest inherited reference\n  const nextReferences = _.uniqBy(\n    [...descendantReferences, ...inheritedReferences],\n    'placeholder'\n  );\n\n  return { link, nextReferences };\n}\n\nexport default function Transclude(source = 'string', options = {}) {\n  const {\n    transclusionSyntax = 'hercule',\n    inheritedParents = [],\n    inheritedReferences = [],\n    inheritedIndent = '',\n    inheritedHeader = 0,\n    resolvers,\n  } = options;\n  const { REGEXP, MATCH_GROUP, INDENT_GROUP, LINK_GROUP } = SYNTAX[\n    transclusionSyntax\n  ];\n  const pattern = cloneRegExp(REGEXP);\n  let inputBuffer = '';\n  let line = 1;\n  let column = 0;\n\n  function transclude(chunk, cb) {\n    const self = this;\n\n    // eslint-disable-next-line consistent-return\n    process.nextTick(() => {\n      if (!chunk.link) {\n        self.push(chunk);\n        return cb();\n      }\n\n      const { parents, indent, header } = chunk;\n      const sourceLine = chunk.line;\n      const sourceColumn = chunk.column;\n      const content = chunk.content;\n\n      let out;\n      try {\n        out = applyReferences(chunk);\n      } catch (error) {\n        self.push(chunk.link);\n        return cb({\n          message: 'Link could not be parsed',\n          path: source,\n          error,\n          line: sourceLine,\n          column: sourceColumn,\n        });\n      }\n\n      const { link, nextReferences } = out;\n      link.content = content;\n\n      const { contentStream, resolvedUrl } = resolveToReadableStream(\n        link,\n        resolvers,\n        content,\n        chunk\n      );\n      if (_.includes(parents, resolvedUrl)) {\n        self.push(link);\n        return cb({\n          message: 'Circular dependency detected',\n          path: resolvedUrl,\n          line: link.line,\n          column: link.column,\n        });\n      }\n\n      // Resolved URL will be undefined for quoted strings: :[exmple](link || \"fallback\" reference:\"string\")\n      const resolvedSource = resolvedUrl || link.source;\n      const resolvedParents = resolvedSource ? parents : undefined;\n\n      const nestedTransclude = new Transclude(resolvedSource, {\n        transclusionSyntax,\n        inheritedParents: resolvedParents,\n        inheritedReferences: nextReferences,\n        inheritedIndent: indent,\n        inheritedHeader: header,\n        resolvers,\n      });\n\n      nestedTransclude\n        .on('readable', function inputReadable() {\n          let streamContent;\n          while ((streamContent = this.read()) !== null) {\n            self.push(streamContent);\n          }\n        })\n        .on('error', err => cb(err))\n        .on('end', () => cb(null, true));\n      contentStream.on('error', err => cb(err));\n      contentStream.pipe(nestedTransclude);\n    });\n  }\n\n  function toToken(chunk) {\n    const content = chunk[MATCH_GROUP];\n    const link = chunk[LINK_GROUP];\n    const indent = chunk[INDENT_GROUP] || '';\n    const level = [...chunk.input.slice(0, chunk.index)]\n      .reverse()\n      .join('')\n      .match(/^[^\\n|\\r|\\r\\n]+ +(#+)$/m);\n\n    const output = { content, line, column };\n    output.link = link;\n    output.source = source;\n    output.parents = [...inheritedParents, source];\n    output.references = [...inheritedReferences];\n    output.indent = inheritedIndent + indent;\n    output.column += content.lastIndexOf(link);\n    output.header = inheritedHeader + (level ? level[1].length : 0);\n\n    ({ line, column } = shiftCursor(content, { line, column }));\n\n    return output;\n  }\n\n  function toSeparators(separator) {\n    // Each line must be processed individually for correct sourcemap output\n    let separators = leftsplit(separator, /(\\r?\\n)/);\n\n    separators = _.map(separators, content => {\n      if (!content) return null;\n\n      const output = { content, line, column };\n      output.source = source;\n      output.indent = inheritedIndent;\n      output.header = inheritedHeader;\n      output.parents = [...inheritedParents];\n\n      ({ line, column } = shiftCursor(content, { line, column }));\n\n      return output;\n    });\n\n    return _.without(separators, null);\n  }\n\n  function tokenize(chunk) {\n    const lastChunk = !chunk;\n    let nextOffset = 0;\n    let match = null;\n    let tokens = [];\n\n    if (chunk) inputBuffer += chunk;\n\n    while ((match = pattern.exec(inputBuffer)) !== null) {\n      // Content prior to match can be returned without transform\n\n      if (match.index > nextOffset) {\n        const separator = inputBuffer.slice(nextOffset, match.index);\n        tokens = tokens.concat(toSeparators(separator));\n      }\n\n      // Match within bounds: [  xxxx  ]\n      if (pattern.lastIndex < inputBuffer.length || lastChunk) {\n        tokens.push(toToken(match));\n\n        // Next match must be after this match\n        nextOffset = pattern.lastIndex;\n        // Match against bounds: [     xxx]\n      } else {\n        // Next match will be the start of this match\n        nextOffset = match.index;\n      }\n    }\n\n    inputBuffer = inputBuffer.slice(nextOffset);\n    pattern.lastIndex = 0;\n\n    // End of input, flush the input buffer\n    if (lastChunk) tokens = tokens.concat(toSeparators(inputBuffer));\n\n    return tokens;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function transform(chunk, encoding, cb) {\n    // Allow objects straight through\n    if (_.isPlainObject(chunk)) return cb(null, chunk);\n\n    async.eachSeries(\n      tokenize(chunk.toString('utf8')),\n      (output, next) => transclude.call(this, output, next),\n      err => {\n        if (err) inputBuffer = '';\n        cb(err);\n      }\n    );\n  }\n\n  function flush(cb) {\n    async.eachSeries(\n      tokenize(),\n      (output, next) => transclude.call(this, output, next),\n      err => {\n        this.push(null);\n        cb(err);\n      }\n    );\n  }\n\n  return through2.obj(transform, flush);\n}\n"]}