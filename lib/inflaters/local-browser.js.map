{"version":3,"sources":["../../src/inflaters/local-browser.js"],"names":[],"mappings":";;;;;kBAoCwB;;AAFxB;;;;;;AAEe,SAAS,OAAT,CAAiB,IAAjB,EAAuB,KAAvB,EAA8B,EAA9B,EAAkC,GAAlC,EAAuC;;;AACpD,SAAO,IAAI,IAAJ,EACJ,EADI,CACD,UADC,EACW,UAAC,GAAD,EAAS;AACvB,QAAI,IAAI,UAAJ,KAAmB,GAAnB,EAAwB;AAC1B,YAAK,IAAL,CAAU,OAAV,EAAmB,EAAE,KAAK,IAAI,aAAJ,EAAmB,MAAM,IAAN,EAA7C,EAD0B;AAE1B,WAF0B;KAA5B;GADc,CADlB,CADoD;CAAvC","file":"local-browser.js","sourcesContent":["// import { Readable } from 'stream';\n\n// export default function inflate() {\n//   const rs = new Readable({ objectMode: true });\n\n//   rs._read = function read() {\n//     this.push('Not implemented');\n//     this.push(null);\n//   };\n\n//   return rs;\n// }\n\n// import request from 'request';\n\n// export default function inflate(link, chunk, cb) {\n//   return request.get(link)\n//     .on('response', (res) => {\n//       if (res.statusCode !== 200) {\n//         this.emit('error', { msg: res.statusMessage, path: link });\n//         cb();\n//       }\n//     });\n// }\n\n// Starting from the http inflater as it might be closer to the \n// backbone app (specifically prose) needs.\n\n// Seems like a possible first step would be to pass a function that would \n// know about the model and how to find a transcluded target.\n// This function's would need to be a Readable stream and take the callback as argument\n// It would be provided when starting TranscludeString:\n//   get(link, cb) \n\nimport request from 'request';\n\nexport default function inflate(link, chunk, cb, get) {\n  return get(link)\n    .on('response', (res) => {\n      if (res.statusCode !== 200) {\n        this.emit('error', { msg: res.statusMessage, path: link });\n        cb();\n      }\n    });\n}\n"]}